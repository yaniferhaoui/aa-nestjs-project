{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/types.ts", "../../src/crypto.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/ban-ts-comment */\n\nimport { Extension } from '@magic-sdk/commons';\nimport {\n  OAuthErrorData,\n  OAuthPayloadMethods,\n  OAuthRedirectError,\n  OAuthRedirectResult,\n  OAuthRedirectConfiguration,\n} from './types';\nimport { createCryptoChallenge } from './crypto';\n\nexport class OAuthExtension extends Extension.Internal<'oauth'> {\n  name = 'oauth' as const;\n  config = {};\n  compat = {\n    'magic-sdk': '>=2.4.6',\n    '@magic-sdk/react-native': false,\n    '@magic-sdk/react-native-bare': false,\n    '@magic-sdk/react-native-expo': false,\n  };\n\n  public loginWithRedirect(configuration: OAuthRedirectConfiguration) {\n    return this.utils.createPromiEvent<void>(async (resolve) => {\n      const { provider, query } = await createURI.call(this, configuration);\n\n      // @ts-ignore - this.sdk.endpoint is marked protected but we need to access it.\n      window.location.href = new URL(`/v1/oauth2/${provider}/start?${query}`, this.sdk.endpoint).href;\n\n      resolve();\n    });\n  }\n\n  public getRedirectResult() {\n    const queryString = window.location.search;\n\n    // Remove the query from the redirect callback as a precaution to prevent\n    // malicious parties from parsing it before we have a chance to use it.\n    const urlWithoutQuery = window.location.origin + window.location.pathname;\n    window.history.replaceState(null, '', urlWithoutQuery);\n\n    return getResult.call(this, queryString);\n  }\n}\n\nconst OAUTH_REDIRECT_METADATA_KEY = 'oauth_redirect_metadata';\n\nasync function createURI(this: OAuthExtension, configuration: OAuthRedirectConfiguration) {\n  // Bust any old, in-progress OAuth flows.\n  await this.utils.storage.removeItem(OAUTH_REDIRECT_METADATA_KEY);\n\n  // Unpack configuration, generate crypto values, and persist to storage.\n  const { provider, redirectURI, scope, loginHint } = configuration;\n  const { verifier, challenge, state } = await createCryptoChallenge();\n\n  /* Stringify for RN Async storage */\n  const storedData = JSON.stringify({\n    verifier,\n    state,\n  });\n\n  await this.utils.storage.setItem(OAUTH_REDIRECT_METADATA_KEY, storedData);\n\n  // Formulate the initial redirect query to Magic's OAuth hub.\n  // Required fields:\n  //   - `magic_api_key`\n  //   - `magic_challenge`\n  //   - `state`\n  //   - `redirect_uri`\n  //   - `platform`\n\n  const query = [\n    `magic_api_key=${encodeURIComponent(this.sdk.apiKey)}`,\n    `magic_challenge=${encodeURIComponent(challenge)}`,\n    `state=${encodeURIComponent(state)}`,\n    `platform=${encodeURIComponent('web')}`,\n    scope && `scope=${encodeURIComponent(scope.join(' '))}`,\n    redirectURI && `redirect_uri=${encodeURIComponent(redirectURI)}`,\n    loginHint && `login_hint=${encodeURIComponent(loginHint)}`,\n  ].reduce((prev, next) => (next ? `${prev}&${next}` : prev));\n\n  return {\n    query,\n    provider,\n    redirectURI,\n  };\n}\n\nfunction getResult(this: OAuthExtension, queryString: string) {\n  return this.utils.createPromiEvent<OAuthRedirectResult>(async (resolve, reject) => {\n    const json: string = (await this.utils.storage.getItem(OAUTH_REDIRECT_METADATA_KEY)) as string;\n\n    const { verifier, state } = JSON.parse(json);\n\n    // Remove the save OAuth state from storage, it stays in memory now...\n    this.utils.storage.removeItem(OAUTH_REDIRECT_METADATA_KEY);\n\n    const parseRedirectResult = this.utils.createJsonRpcRequestPayload(OAuthPayloadMethods.ParseRedirectResult, [\n      queryString,\n      verifier,\n      state,\n    ]);\n\n    // Parse the result, which may contain an OAuth-formatted error.\n    const resultOrError = await this.request<OAuthRedirectResult | OAuthRedirectError>(parseRedirectResult);\n    const maybeResult = resultOrError as OAuthRedirectResult;\n    const maybeError = resultOrError as OAuthRedirectError;\n\n    if (maybeError.error) {\n      reject(\n        this.createError<OAuthErrorData>(maybeError.error, maybeError.error_description ?? 'An error occurred.', {\n          errorURI: maybeError.error_uri,\n          provider: maybeError.provider,\n        }),\n      );\n    }\n\n    resolve(maybeResult);\n  });\n}\n\nexport * from './types';\n", "import { MagicUserMetadata } from '@magic-sdk/types';\n\nexport enum OAuthPayloadMethods {\n  ParseRedirectResult = 'magic_oauth_parse_redirect_result',\n}\n\nexport type OAuthProvider =\n  | 'google'\n  | 'facebook'\n  | 'apple'\n  | 'github'\n  | 'bitbucket'\n  | 'gitlab'\n  | 'linkedin'\n  | 'twitter'\n  | 'discord'\n  | 'twitch'\n  | 'microsoft';\n\nexport interface OAuthErrorData {\n  provider: OAuthProvider;\n  errorURI?: string;\n}\n\nexport interface OpenIDConnectProfile {\n  name?: string;\n  familyName?: string;\n  givenName?: string;\n  middleName?: string;\n  nickname?: string;\n  preferredUsername?: string;\n  profile?: string;\n  picture?: string;\n  website?: string;\n  gender?: string;\n  birthdate?: string;\n  zoneinfo?: string;\n  locale?: string;\n  updatedAt?: number;\n}\n\nexport interface OpenIDConnectEmail {\n  email?: string;\n  emailVerified?: boolean;\n}\n\nexport interface OpenIDConnectPhone {\n  phoneNumber?: string;\n  phoneNumberVerified?: boolean;\n}\n\nexport interface OpenIDConnectAddress {\n  address?: {\n    formatted?: string;\n    streetAddress?: string;\n    locality?: string;\n    region?: string;\n    postalCode?: string;\n    country?: string;\n  };\n}\n\nexport type OpenIDConnectUserInfo = OpenIDConnectProfile &\n  OpenIDConnectEmail &\n  OpenIDConnectPhone &\n  OpenIDConnectAddress & { sub?: string; sources?: Record<string, any> } & Record<string, any>;\n\nexport interface OAuthRedirectResult {\n  oauth: {\n    provider: OAuthProvider;\n    scope: string[];\n    accessToken: string;\n    userHandle: string;\n    userInfo: OpenIDConnectUserInfo;\n  };\n\n  magic: {\n    idToken: string;\n    userMetadata: MagicUserMetadata;\n  };\n}\n\nexport interface OAuthRedirectError {\n  provider: OAuthProvider;\n  error: string;\n  error_description?: string;\n  error_uri?: string;\n}\n\nexport interface OAuthRedirectConfiguration {\n  provider: OAuthProvider;\n  redirectURI: string;\n  scope?: string[];\n  loginHint?: string;\n}\n\nexport enum OAuthErrorCode {\n  InvalidRequest = 'invalid_request',\n  InvalidClient = 'invalid_client',\n  InvalidScope = 'invalid_scope',\n  InvalidGrant = 'invalid_grant',\n  UnauthorizedClient = 'unauthorized_client',\n  UnsupportedResponseType = 'unsupported_response_type',\n  UnsupportedGrantType = 'unsupported_grant_type',\n  UnsupportedTokenType = 'unsupported_token_type',\n  AccessDenied = 'access_denied',\n  ServerError = 'server_error',\n  TemporarilyUnavailable = 'temporarily_unavailable',\n}\n", "import Crypto from 'crypto-js';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\nconst HAS_CRYPTO = typeof window !== 'undefined' && !!(window.crypto as any);\nconst HAS_SUBTLE_CRYPTO = HAS_CRYPTO && !!(window.crypto.subtle as any);\n\n/**\n * Stringifies `bytes` using the OAuth 2.0 `code_verifier` character set.\n */\nfunction bytesToVerifierString(bytes: Uint8Array) {\n  return Array.from(bytes)\n    .map((value: number) => CHARSET[value % CHARSET.length])\n    .join('');\n}\n\n/**\n * Stringifies argument (as CryptoJS `WordArray` or EcmaScript `ArrayBuffer`)\n * and encodes to URL-safe Base64.\n */\nfunction base64URLEncodeFromByteArray(wordArray: Crypto.WordArray): string;\nfunction base64URLEncodeFromByteArray(arrayBuffer: ArrayBuffer): string;\nfunction base64URLEncodeFromByteArray(arg: Crypto.WordArray | ArrayBuffer): string {\n  const makeURLSafe = (base64: string) => {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  };\n\n  if (arg instanceof ArrayBuffer) {\n    const bytes = new Uint8Array(arg);\n    const utf8Binary = Array.from(bytes)\n      .map((value) => String.fromCharCode(value))\n      .join('');\n\n    const base64 = btoa(utf8Binary);\n    return makeURLSafe(base64);\n  }\n\n  return makeURLSafe(Crypto.enc.Base64.stringify(arg));\n}\n\n/**\n * Produces a SHA-256 hash of the given `message`. This function first attempts\n * to use the browser's built-in `SubtleCrypto` API, falling back to\n * CryptoJS if required.\n */\nasync function sha256(message: string) {\n  if (HAS_SUBTLE_CRYPTO) {\n    const bytes = new TextEncoder().encode(message);\n    return crypto.subtle.digest('SHA-256', bytes).then(base64URLEncodeFromByteArray);\n  }\n\n  return base64URLEncodeFromByteArray(Crypto.SHA256(message));\n}\n\n/**\n * Creates a cryptographically random string using the browser's built-in\n * `Crypto` API, falling back to `Math.random` if required.\n */\nfunction createRandomString(size: number) {\n  const bytes = new Uint8Array(size);\n\n  if (HAS_CRYPTO) {\n    window.crypto.getRandomValues(bytes);\n  } else {\n    for (let i = 0; i < size; i += 1) bytes[i] = Math.floor(Math.random() * Math.floor(255));\n  }\n\n  return bytesToVerifierString(bytes);\n}\n\n/**\n * Creates OAuth 2.0-compatible `code_verifier`, `code_challenge`, and `state`\n * parameters.\n */\nexport async function createCryptoChallenge() {\n  const state = createRandomString(128);\n  const verifier = createRandomString(128);\n  const challenge = await sha256(verifier);\n  return { verifier, challenge, state };\n}\n"],
  "mappings": "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",
  "names": ["Extension", "OAuthPayloadMethods", "OAuthErrorCode", "Crypto", "CHARSET", "HAS_CRYPTO", "HAS_SUBTLE_CRYPTO", "bytesToVerifierString", "bytes", "value", "base64URLEncodeFromByteArray", "arg", "makeURLSafe", "base64", "utf8Binary", "Crypto", "sha256", "message", "__async", "createRandomString", "size", "i", "createCryptoChallenge", "state", "verifier", "challenge", "OAuthExtension", "Extension", "configuration", "resolve", "__async", "provider", "query", "createURI", "queryString", "urlWithoutQuery", "getResult", "OAUTH_REDIRECT_METADATA_KEY", "redirectURI", "scope", "loginHint", "verifier", "challenge", "state", "createCryptoChallenge", "storedData", "prev", "next", "reject", "_a", "json", "parseRedirectResult", "resultOrError", "maybeResult", "maybeError"]
}
